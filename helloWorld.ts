/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/. 
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.1.10-SNAPSHOT
 *
 */
import {
    ResultCodes,
    RequestFlow,
    RequestFlowBuilder,
    CallParams,
} from '@fluencelabs/fluence/dist/internal/compilerSupport/v1';
import { FluencePeer } from '@fluencelabs/fluence';



 const registerHelloWorldImpl = (peer: FluencePeer) => {
     return  (
     options: { serviceId: string },
        service: {
            hello: (arg0: string, callParams: CallParams<'arg0'>) => void;
        },
 ) => {
           peer.callServiceHandler.use((req, resp, next) => {
               if (req.serviceId !== options.serviceId) {
                   next();
                   return;
               }
       
               
 if (req.fnName === 'hello') {
     
 const callParams = {
     ...req.particleContext,
     tetraplets: {
         arg0: req.tetraplets[0]
     },
 };
 resp.retCode = ResultCodes.success;
 service.hello(req.args[0], callParams); resp.result = {}

 }
    
       
               next();
           });
       }
 }
 
 export const registerHelloWorld = registerHelloWorldImpl(FluencePeer.default);
 
 declare module "@fluencelabs/fluence" {
     interface FluencePeer {
         registerHelloWorld:  (
     options: { serviceId: string },
        service: {
            hello: (arg0: string, callParams: CallParams<'arg0'>) => void;
        },
 ) => void;
     }
 }

 FluencePeer.prototype.registerHelloWorld = function (o, s) {
    return registerHelloWorldImpl(this)(o, s);
 };

    
 const sayHelloImpl = (peer: FluencePeer) => {
     return async  (, config?: {ttl?: number}): Promise<void> => {
        let request: RequestFlow;
        const promise = new Promise<void>((resolve, reject) => {
            const r = new RequestFlowBuilder()
                .disableInjections()
                .withRawScript(
                    `
    (xor
 (seq
  (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
  (call %init_peer_id% ("hello_world" "hello") ["hello, world"])
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
)

                `,
                )
                .configHandler((h) => {
                    h.on('getDataSrv', '-relay-', () => {
                        return peer.connectionInfo.connectedRelays[0];
                    });    
                    
                    
                    h.onEvent('errorHandlingSrv', 'error', (args) => {
                        const [err] = args;
                        reject(err);
                    });
                })
                .handleScriptError(reject)
                .handleTimeout(() => {
                    reject('Request timed out for sayHello');
                })
            if(config && config.ttl) {
                r.withTTL(config.ttl)
            }
            request = r.build();
        });
        await peer.initiateFlow(request!);
        return Promise.race([promise, Promise.resolve()]);
    }
}

 export const sayHello = sayHelloImpl(FluencePeer.default);
 
 declare module "@fluencelabs/fluence" {
     interface FluencePeer {
         sayHello: (, config?: {ttl?: number}) => Promise<void>
     }
 }

FluencePeer.prototype.sayHello = function (...args) {
    return sayHelloImpl(this)(...args);
 };
      